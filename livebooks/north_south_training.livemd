# Reinforcement Learning

```elixir
my_app_root = Path.join(__DIR__, "..")

Mix.install(
  [
    {:boat_learner, path: my_app_root, env: :dev}
  ],
  config_path: Path.join(my_app_root, "config/config.exs"),
  lockfile: Path.join(my_app_root, "mix.lock")
)
```

## Section

```elixir
alias VegaLite, as: Vl

defmodule MyServer do
  use GenServer

  @base_plot Vl.new(width: 600, height: 600)

  def init(_opts) do
    {:ok, %{layers: []}}
  end

  def start_link(opts), do: GenServer.start_link(__MODULE__, opts, name: __MODULE__)

  def plot(x, y, episode) do
    GenServer.cast(__MODULE__, {:plot, %{x: x, y: y, episode: episode}})
  end

  def get_layers, do: GenServer.call(__MODULE__, :get_layers)
  def reset, do: GenServer.call(__MODULE__, :reset)

  def handle_call(:reset, _from, state) do
    {:ok, init} = init([])
    {:reply, state.layers, init}
  end

  def handle_call(:get_layers, _from, state) do
    {:reply, state.layers, state}
  end

  def handle_cast({:plot, %{x: x, y: y, episode: episode}}, state) do
    layers = [new_layer(x, y, episode) | state.layers]
    {:noreply, %{state | layers: layers}}
  end

  @colors ~w(blue magenta red green black yellow gray pink light_green cyan)

  defp new_layer(x, y, episode) do
    Vl.new()
    |> Vl.data_from_values(%{x: x, y: y, sequence: Enum.with_index(x, fn _, idx -> idx end)})
    |> Vl.mark(:line,
      stroke_opacity: 0.5,
      opacity: 0.5,
      color: Enum.at(@colors, rem(episode, 10)),
      tooltip: true
    )
    |> Vl.encode_field(:x, "x", type: :quantitative, scale: [domain: [-10, 10]])
    |> Vl.encode_field(:y, "y", type: :quantitative, scale: [domain: [0, 200]])
    |> Vl.encode_field(:order, "sequence")
  end

  def draw(n) do
    layers = get_layers() |> Enum.take(n)

    @base_plot |> Vl.layers(layers)
  end
end
```

```elixir
pid = Process.whereis(MyServer)
pid && Process.unlink(pid)
pid && Process.exit(pid, :kill)

MyServer.start_link(kino_frame: nil)

# plot = Vl.new(width: 600, height: 600)

# Kino.Frame.periodically(frame, 2000, {plot, nil}, fn {plot, prev_last_layer} ->
#   layers = MyServer.get_layers()
#   last_layer = Enum.at(layers, 0)

#   if last_layer != prev_last_layer do
#     Kino.Frame.render(frame, plot |> Vl.layers(layers))
#   end

#   {:cont, {plot, last_layer}}
# end)
```

```elixir
plot_trajectory = fn {episode, num_points, trajectory} ->
  episode = Nx.to_number(episode)
  num_points = Nx.to_number(num_points)

  if num_points > 0 do
    x = Nx.to_flat_list(trajectory[[0..(num_points - 1), 0]])
    y = Nx.to_flat_list(trajectory[[0..(num_points - 1), 1]])
    MyServer.plot(x, y, episode)
  end
end
```

```elixir
MyServer.reset()
{t, _} = :timer.tc(fn -> BoatLearner.Navigation.SouthToNorth.train(plot_trajectory) end)

"#{t / 1_000} ms"
```

```elixir
MyServer.draw(20)
```

```elixir
x = Enum.map(0..360, &((&1 - 180) * :math.pi() / 180)) |> Nx.tensor()

Vl.new()
|> Vl.data_from_values(%{
  y: BoatLearner.Simulator.speed(BoatLearner.Simulator.init(), x) |> Nx.to_flat_list(),
  x: Nx.to_flat_list(x)
})
|> Vl.encode_field(:x, "x", type: :quantitative)
|> Vl.encode_field(:y, "y", type: :quantitative)
|> Vl.mark(:line, tooltip: true, order: [field: "x"])
```

```elixir
2.1 * 180 / :math.pi()
```
